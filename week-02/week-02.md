## 목표 분량

- [x]  바킹독 3강 수강
- [x]  3강 연습문제 풀이
- [x]  바킹독 4강 수강
- [ ]  4강 연습문제 풀이
- [x]  바킹독 5강 수강
- [ ]  5강 연습문제 풀이
- [ ]  1주차 연습문제 풀이

## 0x03 배열

[강의 링크](https://youtu.be/mBeyFsHqzHg?si=vDtxeT4T8ImBuzyZ)

### 정의와 성질

- 메모리상에 원소를 연속하게 배치한 자료구조
- **O(1)에 K번째 원소를 확인하거나 변경 가능**
- 추가적으로 소모되는 메모리 양이 없음
- Cache hit rate가 높다.
- 메모리상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

### 기능과 구현

- O(1)로 가능한 연산
    - 특정 위치의 원소를 확인 및 변경
    - 배열 맨 뒤 원소를 추가 및 제거
- O(n)이 소요되는 연산
    - 임의의 위치에 원소를 추가 및 제거
        
        원소들을 뒤로 1칸씩 밀어야 한다.
        
- 배열 전체를 특정 값으로 초기화
    - memset -실수의 여지 존재, 비추천
    - for문 - 나쁘지 않으나 코드가 길다.
    - fill - 실수할 여지도 적고 코드도 짧다.
    
    ```cpp
    #include<algorithm>
    
    int arr[10];
    
    fill(a, a+10, 0);
    ```
    

### STL vector

- 배열과의 차이점은 크기 변경이 자유롭다는 점이다. (메모리 연속성은 동일)
- 인접리스트 저장 시 벡터 사용이 유리하나, 다른 상황에서는 굳이 벡터를 사용하지 않아도 좋다.
- O(n) insert, erase
- O(1) push_back, pop_back
- O(n) push_front, pop_front
- ‘=’는 deep copy를 수행하므로 사용에 유의 (시간복잡도 O(n) 소요)
- range based for loop
    
    ```cpp
    #include<vector>
    
    vector<int> v1 = {1, 2, 3, 4};
    
    for(int item : v1)
    	item = 1 // 원본 벡터에 반영되지 않음
    	
    for(int& item : v1)
    	item = 1 // 원본 벡터에 반영
    ```
    
    for문 사용해도 괜찮다.
    

## 0x04 연결리스트

[강의 링크](https://youtu.be/C6MX5u7r72E?si=EH5iHl_-Dc_ouaUe)

### 정의와 성질

- 원소들은 흩어져있으며, 각 원소가 다음 원소의 위치를 기억하는 형태로 구현된 리스트
- k번째 원소를 확인 또는 변경하기 위해 O(k)가 필요
- 임의의 위치에 원소를 추가하거나 제거하는 경우 O(1)
- 메모리 상 데이터가 연속적이지 않아 Cache hit rate가 낮으나 할당이 쉽다.
- 종류
    - 단일 연결 리스트
        
        각 원소가 다음 원소의 주소만 기억
        
    - 이중 연결 리스트 (STL의 list)
        
        각 원소가 다음 원소와 이전 원소의 주소를 기억
        
    - 원형 연결 리스트
        
        맨 끝 원소의 다음 원소 주소 자리에 첫 원소의 주소가 들어간다.
        
- 배열 vs 연결리스트 (선형 자료구조)
    
    
    |  | 배열 | 연결 리스트 |
    | --- | --- | --- |
    | k번째 원소 접근 | O(1) | O(k) |
    | 임의의 위치에 원소 추가 및 제거 | O(n) | O(1) |
    | 메모리 상의 배치 | 연속 | 불연속 |
    | 추가적으로 필요한 공간 | X | O(n) |
    
    엄밀히 말하자면, 연결리스트에서 임의의 위치에 원소 추가 및 제거를 진행할 경우 해당 위치까지 탐색이 필요하기 때문에 탐색에 소요되는 시간복잡도를 고려해여 한다.
    

### 기능과 구현

- 임의의 위치에 있는 원소를 확인 및 변경 O(n)
    
    임의의 위치까지 찾아가려면 첫 원소부터 순차적 접근이 필요하다.
    
- 임의의 위치에 원소를 추가 O(1)
    
    배열처럼 추가 위치 뒤쪽의 원소를 옮기는 작업을 진행할 필요가 없다.
    
    추가를 원하는 위치의 앞 원소가 기억하는 다음 원소의 주소값만 바꾸어 주면 된다.
    
    추가하고자 하는 위치의 주소를 알 경우에만 O(1)이 소요된다. 탐색해야 한다면 O(1)이라고 할 수 없다.
    
- 임의의 위치의 원소 제거 O(1)
    
    제거를 원하는 원소의 앞 원소가 기억하는 다음 원소의 주소값만 바꾸어 주면 된다.
    
    제거하고자 하는 위치의 주소를 알 경우에만 O(1)이 소요된다. 탐색해야 한다면 O(1)이라고 할 수 없다.
    
- 직접 구현 (면접 목적으로 학습 필요, STL 미허용시 구현 필요 )
    
    ```cpp
    struct NODE {
    	struct NODE *prev, *next;
    	int data;
    };
    ```
    

### STL list

- STL을 사용할 수 있는 상황이라면 굳이 연결리스트를 구현하지 않는 것이 좋다.
- push_back, pop_back, push_front, pop_front는 O(1)
- iterator가 주소 역할을 한다.

## 0x05 스택

[강의 링크](https://youtu.be/0DsyCXIN7Wg?si=Wch1yjiD-P2SL7Uw)

### 정의와 성질

- 한쪽 끝에서만 원소를 넣거나 뺄 수 있는 자료구조
- 먼저 들어간 원소가 가장 나중에 나온다. (First In Last Out, FILO)
- 큐, 덱도 특정 위치에서만 원소를 넣고 뺄 수 있어 이들을 묶어 restricted structure라고 부르기도 한다.
- 원소의 추가 및 제거 O(1)
- 최상단 원소 확인 O(1)
- 최상단이 아닌 나머지 원소의 확인 및 변경이 원칙적으로 불가능
- 스택 활용 예시에서는 애초에 스택에서 제공하는 기능 외의 것이 필요하지 않는 경우가 대다수이다.

### 기능과 구현

- 배열 또는 연결리스트로 구현 가능
    - 배열을 이용한 구현이 더 쉽다.
- 연결리스트를 이용한 구현
    - 원소를 담을 큰 배열 하나
        
        인덱스 0부터 데이터 삽입
        
    - 인덱스를 저장할 변수 하나
        
        다음에 원소가 추가될 때 삽입되어야 할 위치의 인덱스
        

### STL stack

- push, pop, top, empty, size
- 스택이 비었을 때 top/pop 호출 시 runtime error 발생