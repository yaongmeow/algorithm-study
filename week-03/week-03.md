## 목표 분량

- [x]  바킹독 6강 수강
- [x]  바킹독 7강 수강
- [x]  바킹독 8강 수강
- [ ]  바킹독 9강 수강
- [ ]  바킹독 10강 수강

## 0x06 큐

### 정의와 성질

- 한 쪽 끝에 데이터를 넣고 다른 쪽 끝으로 데이터가 나온다.
- First In First Out, FIFO
- 원소의 추가와 제거의 시간복잡도가 O(1)
- 제일 앞 또는 뒤가 아닌 원소들의 확인 및 변경이 불가능
- 가장 앞/뒤의 원소 확인 시간복잡도 O(1)
- 원소가 들어가는 쪽 = rear
- 원소가 제거되는 쪽 = front

### 기능과 구현

- 배열 또는 연결리스트로 구현 가능 (배열이 더 쉬움)
- 배열을 통한 구현
    - 큰 배열 하나 (연산 횟수 이상)
    - 앞, 뒤를 가리킬 변수 두개 (head, tail)
        - head = 가장 앞 원소의 인덱스
        - tail = 가장 뒤 원소의 인덱스 + 1
    - 맨 처음에는 head, tail이 0번지를 가리키며 시작
    - 맨 앞의 원소를 뺄 때 head 값을 1만큼 증가
    - 맨 뒤에 원소를 넣을 때 tail 위치에 넣고, tail 값을 1만큼 증가
    - 점점 배열의 앞부분에 빈공간이 생긴다.
        - 큐의 원소가 들어갈 배열을 원형으로 만들어 해결 가능
        - 관념적 원이며, 실제로는 일반 배열로 구현
            - tail이 마지막 인덱스에 데이터를 넣었으며 head가 0이 아닌 경우 tail을 다시 0으로 만들어 앞부분의 빈공간을 재사용한다.
            - 원소의 개수가 배열 크기보다 커지지 않는 이상 문제가 없다.
        - 배열 크기를 최대 push 횟수보다 크게 만들 경우 원형 큐를 사용하지 않아도 된다.

### STL queue

- 헤더 `#include <queue>`
- 큐는 보통 bfs, flood fill을 할 때 사용한다.
- 빈 큐에 front, back, pop 할 경우 runtime error 발생

## 0x07 덱

### 정의와 성질

- 양쪽 끝에서 삽입과 삭제가 전부 가능하다.
- double ended queue
- 원소의 추가 및 제거의 시간복잡도 O(1)
- 제일 앞 또는 뒤의 원소 확인 시간복잡도 O(1)
- 제일 앞 또는 뒤가 아닌 원소들의 확인이나 변경이 원칙적으로 불가능
    - STL deque에서는 예외적으로 인덱스를 이용한 접근이 가능

### 기능과 구현

- 배열 또는 연결리스트로 구현 가능 (배열이 더 쉬움)
- 배열을 통한 구현
    - 큰 배열 하나
    - 앞, 뒤를 가리킬 변수 두개 (head, tail)
        - head = 가장 앞 원소의 인덱스
        - tail = 가장 뒤 원소의 인덱스 + 1
    - 큐와 비교하였을 때 배열의 크기와 head, tail의 초기 위치값이 다르다.
        - 큐의 경우 삽입이 tail에만 발생하지만, 덱의 경우 head에도 삽입이 가능하다.
        - 배열의 크기가 max(최대 연산 횟수)*2+1이어야 한다.
        - head, tail의 초기 위치는 max여야 한다.

### STL deque

- 헤더 `#include <deque>`
- STL 벡터 + push_front와 pop_front를 O(1)에 처리 가능
- 반복문 순회 가능
- 인덱스를 이용한 원소 접근 가능
- 벡터와 달리 원소가 메모리 상에 연속적으로 배치되어 있지 않다.
- 잦은 push_front와 pop_front가 필요하지 않으면 벡터를 사용해도 되는 문제에 deque를 사용할 필요는 없다.

## 0x08 스택의 활용 - 수식의 괄호 쌍

### 수식의 괄호쌍이란?

- 주어진 괄호 문자열이 올바른지 판단하는 것

### 문제 해결을 위한 관찰

- 닫는 괄호는 가장 최근에 들어온 여는 괄호와 짝을 지어 없애는 명령이라고 생각한다.
- 올바르지 않은 괄호 쌍 판단
    - 닫는 괄호가 가장 최근의 여는 괄호와 짝이 맞지 않는 경우
    - 닫는 괄호를 이용한 여는 괄호 소진 작업이 다 끝났는데 남은 여는 괄호가 존재하는 경우
    - 닫는 괄호가 남았지만 여는 괄호가 전부 소진된 경우
1. 여는 괄호 등장 시 스택에 추가
2. 닫는 괄호가 나오는 경우
    1. 스택이 비어있으면 올바르지 않는 괄호 쌍
    2. 스택의 top과 닫는 괄호의 짝이 맞지 않으면 올바르지 않는 괄호 쌍
    3. 스택의 top과 닫는 괄호의 짝이 맞으면 pop
3. 과정 종료 후 스택이 비어있으면 올바른 괄호 쌍, 아닐 경우 올바르지 않은 괄호 쌍